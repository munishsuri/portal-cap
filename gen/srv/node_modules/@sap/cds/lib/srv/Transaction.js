const cds = require('../index'), { Context } = cds.Request
const _context = Symbol()

/**
 * This is the implementation of the `srv.tx(req)` method. It constructs
 * a new Transaction as a derivate of the `srv` (i.e. {__proto__:srv})
 * @returns { Transaction & import('./Service-api') }
 */
module.exports =  function (req) { const srv = this
  if (srv.context) return srv
  if (!req) {
    // called as srv.tx() -> new root transaction
    return RootTransaction.for (srv, new Context)
  }
  if (req instanceof Context) {
    // called for a nested req -> nested tx
    if (req.context) return NestedTransaction.for (srv, req.context)
    // called for a req with a root tx -> nested tx
    if (req._tx) return NestedTransaction.for (srv, req)
    // called for a top-level req -> root tx
    else return req._tx = RootTransaction.for (srv, req)
  }
  if (req[_context]) {
    // called again for an arbitrary context object -> see below
    return NestedTransaction.for (srv, req[_context])
  } else {
    // called first time for an arbitrary context object
    const root = new Context(req); Object.defineProperty (req, _context, {value:root})
    return RootTransaction.for (srv, root)
  }
}


class Transaction {

  /**
   * Returns an already started tx for given srv, or creates a new instance
   */
  static for (srv,root) {
    const txs = root.transactions || (root.transactions = new Map)
    let tx = txs.get (srv)
    if (!tx) {
      tx = new this (srv,root)
      txs.set (srv,tx)
    }
    return tx
  }

  constructor (srv,root) {
    const proto = new.target.prototype
    const tx = Object.create(srv)
    if ('begin' in srv) tx.dispatch = tx.start = Transaction.prototype.start
    tx.commit   = proto.commit.bind(tx)
    tx.rollback = proto.rollback.bind(tx)
    tx.context = root
    tx.ready = false
    return tx
  }

  /**
   * Used before the first srv.dispatch in a transaction, to ensure the
   * service's implementation of .begin is called appropriately.
   */
  async start (req) {
    if (req.query || req.event !== 'BEGIN') {
      if (!this.ready) this.ready = this.begin()
      await this.ready //> parallel .dispatch events queue here
      delete this.dispatch
    }
    return this.__proto__.dispatch.call (this,req)
  }

  /**
   * In addition to srv.commit, resets the transaction to initial state,
   * in order to re-.start on subsequently .dispatched events.
   */
  async commit (res) {
    if (this.ready) { //> nothing to do if no transaction started at all
      if (this.__proto__.commit) await this.__proto__.commit.call (this,res)
      this.dispatch = this.start
      this.ready = false
    }
    return res
  }

  /**
   * In addition to srv.rollback, resets the transaction to initial state,
   * in order to re-.start on subsequently .dispatched events.
   */
  async rollback (err) {
    if (this.ready) { //> nothing to do if no transaction started at all
      if (this.__proto__.rollback) await this.__proto__.rollback.call (this,err)
      this.dispatch = this.start
      this.ready = false
    }
    if (err) throw err
  }

}


class RootTransaction extends Transaction {

  /**
   * In addition to srv.commit, ensures all nested transactions
   * are informed by emitting 'succeesed' event to them all.
   */
  async commit (res) {
    try {
      await this.context.emit ('succeeded',res)
      await super.commit (res)
      await this.context.emit ('done')
    } catch (err) {
      await this.rollback (err)
    }
    return res
  }

  /**
   * In addition to srv.rollback, ensures all nested transactions
   * are informed by emitting 'failed' event to them all.
   */
  async rollback (err) {
    try {
      await this.context.emit ('failed',err)
      await super.rollback (err)
    } finally {
      await this.context.emit ('done')
    }
    if (err) throw err
  }
}


class NestedTransaction extends Transaction {

  /**
   * Registers event listeners with the root context, to commit or rollback
   * when the root tx is about to commit or rollback.
   * @param {import ('../req/context')} root
   */
  constructor (srv,root) {
    super (srv,root)
    root.before ('succeeded', ()=> this.commit())
    root.before ('failed', ()=> this.rollback())
    if ('end' in srv) root.once ('done', ()=> srv.end())
  }

}
