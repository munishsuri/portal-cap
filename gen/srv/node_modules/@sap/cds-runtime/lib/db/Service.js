const cds = global.cds || require('@sap/cds/lib')
const { SELECT } = cds.ql
const { Transform } = require('stream')

/*
 * generic queries
 */
const queries = require('./query')

/*
 * generic handlers
 */
const generic = require('./generic')

module.exports = class DatabaseService extends cds.Service {
  constructor (...args) {
    super(...args)

    // REVISIT: official db api
    this._queries = queries

    // REVISIT: official db api
    for (const each in generic) {
      this[`_${each}`] = generic[each]
    }

    // REVISIT: ensures tenant-aware this.model if this is a transaction -> this should be fixed in mtx integration, not here
    this._ensureModel = async function (req) {
      if (cds.version < '4.4' && 'then' in this.dbc) await this.dbc
      if (this.context) this.model = this.context._model || req._model
    }
    this._ensureModel._initial = true

    // REVISIT: how to generic handler registration?
  }

  set model (m) {
    // Ensure the model we get has unfolded entities for localized data, drafts, etc.
    // Note: cds.deploy and some tests set the model of cds.db outside the constructor
    super.model = m && 'definitions' in m ? cds.compile.for.odata(m) : m
  }

  /*
   * tx
   */
  async begin () {
    if (cds.version < '4.4') {
      this.dbc = this.acquire(this.context).then(dbc => {
        this.dbc = dbc
      })
      return this.emit('BEGIN')
    } else {
      this.dbc = await this.acquire(this.context)
      await this.emit('BEGIN')
    }
  }

  async commit () {
    // only release on successful commit as otherwise released on rollback
    await this.emit('COMMIT')
    this.release(this.dbc)
  }

  async rollback () {
    try {
      await this.emit('ROLLBACK')
    } finally {
      this.release(this.dbc)
    }
  }

  /*
   * streaming
   */
  _runStream (streamQuery, result) {
    this.run(streamQuery).then(stream => {
      if (!stream) {
        result.push(null)
      } else {
        stream.value.pipe(result)
      }
    })
  }

  stream (query) {
    // aynchronous API: cds.stream(query)
    if (typeof query === 'object') {
      return new Promise(async (resolve, reject) => {
        try {
          const res = await this.run(Object.assign(query, { _streaming: true }))
          resolve((res && res.value) || res)
        } catch (e) {
          reject(e)
        }
      })
    }

    // synchronous API: cds.stream('column').from(entity).where(...)
    return {
      from: (...args) => {
        const streamQuery = SELECT.from(...args)
        if (!streamQuery.SELECT.columns || streamQuery.SELECT.columns.length !== 0) {
          streamQuery.columns([query])
        }
        delete streamQuery.SELECT.one
        streamQuery._streaming = true

        const result = new Transform({
          transform (chunk, encoding, callback) {
            this.push(chunk)
            callback()
          }
        })

        if (!streamQuery.SELECT.where) {
          return {
            where: (...args) => {
              streamQuery.where(...args)
              this._runStream(streamQuery, result)

              return result
            }
          }
        }

        this._runStream(streamQuery, result)

        return result
      }
    }
  }
}
