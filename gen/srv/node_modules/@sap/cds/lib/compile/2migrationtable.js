const path = require('path')
const cdsc = require('./_cdsc')
const MIGRATIONTABLE = require('../utils/migrationtable')
const cds = require('../index')

module.exports = async (model, lastDevVersion, srcPath, options) => {
  options.beta = { 'to.hdi.migration': true }
  const { hdiArtifacts: hdbTables, targetState, stateChanges } = cdsc.to.hdi.migration(model, lastDevVersion, options);
  const annotations = new Set(cds.reflect(model).all(e => e.kind === 'entity' && e['@cds.persistence.journal'] === true && !e['$syntax']).map(e => e.name))
  const hdiArtifacts = []

  for (const [fileName, createStatement] of Object.entries(hdbTables)) {
    const extName = path.extname(fileName)
    if (extName === '.hdbtable') {
      const eName = path.parse(fileName).name
      if (annotations.has(eName)) {
        const match = createStatement.match(/(COLUMN TABLE\s+)(\w+)/)
        if (!match || match.length !== 3) {
          throw Error(`Invalid migration table statement encountered:\n${createStatement}`)
        }
        hdiArtifacts.push(await _2migrationtable(srcPath, eName + '.hdbmigrationtable', match[2], createStatement, stateChanges[eName]))
      } else {
        hdiArtifacts.push({ content: createStatement, file: fileName })
      }
    } else {
      hdiArtifacts.push({ content: createStatement, file: fileName })
    }
  }
  return { hdiArtifacts, targetState }
}

/**
 * Returns an object providing access to the .hdbmigrationtable file content and its corresponding filename.
 *
 * @param {String} srcPath Fully quailified path of the directory containing .hdbmigrationtable files
 * @param {String} fileName File name of the .hdbmigrationtable file
 * @param {String} tableName Name of the HANA table
 * @param {String} newTableStatement Create statement used for the == version
 * @param {String[]} stateChanges ALTER to add
 * @returns {Object} Providing access to 'content' and 'fileName'.
 */
async function _2migrationtable(srcPath, fileName, tableName, newTableStatement, stateChanges) {
  const descriptor = await MIGRATIONTABLE.read(path.join(srcPath, fileName))

  if (descriptor) {
    // strip comments
    if (!_isEqualTableStatement(newTableStatement, descriptor.tableStatement)) {
      // adding new changeset if change exist, ignore otherwise
      return {
        content: `== version=${descriptor.version + 1}
${newTableStatement}\n
${_getChangeset(stateChanges, descriptor.version + 1, tableName)}

${descriptor.migrations}`, file: fileName, changed: true
      }
    } else {
      // existing migration file version
      return { content: descriptor.content, file: fileName, changed: false }
    }
  }
  // initial migration file version
  return { content: `== version=1\n${newTableStatement} `, file: fileName, changed: true }
}

function _isEqualTableStatement(a, b) {
  return MIGRATIONTABLE.parseTableStatement(a).replace(/\s/g, '') === MIGRATIONTABLE.parseTableStatement(b).replace(/\s/g, '')
}

function _getChangeset(stateChanges, version, tableName) {
  if (stateChanges && stateChanges.length > 0) {
    return `== migration=${version}\n${stateChanges.join('\n')}`
  }
  return `== migration=${version}\nUnsupported state change - this version only supports property add operations.
--Manual editing required - insert a valid migration statement, e.g.:
--ALTER TABLE ${tableName} DROP(<column name>);
--RENAME COLUMN ${tableName}.<column name> TO <new column name>;`
}