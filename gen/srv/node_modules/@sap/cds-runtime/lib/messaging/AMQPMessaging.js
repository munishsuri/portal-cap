const cds = global.cds || require('@sap/cds/lib')
const MessagingService = require('./service')
const ClientAmqp = require('@sap/xb-msg-amqp-v100').Client
const { topic, queueName } = require('./common-utils/naming-conventions')
const { connect, disconnect } = require('./common-utils/connections')
const queued = require('./common-utils/queued')
const { sender } = require('./common-utils/client')
// REVISIT: no console
const _error = console.error

const LOG = cds.log('messaging')

const _depcrecated = options => {
  const cred = options && options.credentials
  if (cred) {
    if (cred.prefix) throw new Error(`'prefix' is not supported anymore.`)
    if (cred.queue) throw new Error(`'queue' property moved from credentials section to top-level options.`)
    if (cred.queueConfig) throw new Error(`'queueConfig' is now merged with the 'queue' property.`)
  }
  if (options.queue && typeof options.queue !== 'object') {
    throw new Error(`'queue' must be an object with a 'name' property and additional configuration options.`)
  }
}

class AMQPMessaging extends MessagingService {
  async init () {
    _depcrecated(this.options)
    const { optionsClient, optionsApp } = this._options(this.options)
    if (this.options.queue) {
      const queueConfig = { ...this.options.queue }
      delete queueConfig.name
      if (Object.keys(queueConfig).length) this.queueConfig = queueConfig
    }
    this.optionsClient = optionsClient
    this.optionsApp = optionsApp
    this.subscriptions = {
      queue: null,
      topics: new Set()
    }
    this.listening = false
    this.ready = false
    this.token = null // stored by management APIs
    this.client = new ClientAmqp(optionsClient.amqp)
    this.sender = sender(this.client, this.optionsApp)
    // enables queued async operations (without awaiting)
    this.queued = queued()
    await connect(this.client)

    cds.once('listening', () => {
      this.ready = true
      this.listen()
    })

    return super.init()
  }

  emit (event, ...etc) {
    const msg = this.message4(event, ...etc)
    LOG._debug && LOG.debug('Emit', { topic: msg.event })
    return this.queued(this._emit)(msg, this.sender)
  }

  // inbound -> listen to channel (once)
  on (topic, handler) {
    if (!this.subscriptions.queue) {
      const queue = queueName(this.options, this.optionsClient, this.optionsApp)
      this.subscriptions.queue = queue
      this.queued(this._putQueue)(queue, this)
    }
    if (!this.subscriptions.topics.has(topic)) {
      this.queued(this._addSubscription)(this.subscriptions.queue, topic, this)
      this.subscriptions.topics.add(topic)
    }
    this.listen()
    return super.on(topic, handler)
  }

  listen () {
    const queue = this.subscriptions.queue
    if (queue && !this.listening && this.ready) {
      this.listening = true
      this.queued(this._addDataListener)(this.client, queue, async (_event, _payload, { done, failed }) => {
        const data = _payload.data
        const headers = { ..._payload }
        delete headers.data
        try {
          await super.emit({ event: _event, data, headers, inbound: true })
          done()
        } catch (e) {
          failed()
          _error(e)
        }
      })
    }
  }

  disconnect () {
    return disconnect(this.client)
  }

  topic (event, service) {
    return topic(event, service, this.optionsClient)
  }
}

module.exports = AMQPMessaging
