const fs = require('@sap/cds-foss')('fs-extra')

const migrationtable = module.exports = { read, parse, parseTableStatement, validate }

async function read(filePath) {
  if (await fs.pathExists(filePath)) {
    return migrationtable.parse(await fs.readFile(filePath, { encoding: 'utf8' }))
  }
  return null
}

/**
 * Validates the given .hdbmigrationtable file content and returns version,
 * tableStatement and migration step details.
 *
 * @param {String} content
 * @returns {version, tableStatement, migrations}
 */
function parse(content) {
  const rows = content.split('\n')
  migrationtable.validate(rows)
  const version = _parseVersion(rows)
  const migrations = _parseMigrations(rows)
  const tableStatement = _parseTableStatement(rows)

  return { version, tableStatement, migrations, content };
}

function validate(rows) {
  let isVersion = false, isTableBegin = false, isTableEnd = false, isMigration = false
  return rows.forEach(row => {
    if (/^== version=/.test(row)) {
      isVersion = true;
      if (isTableBegin || isTableEnd || isMigration) {
        throw new Error(`Invalid format: content is malformed, version defintion must be very first statement`)
      }
    } else if (/^COLUMN TABLE/.test(row)) {
      if (!isVersion) {
        throw new Error(`Invalid format: content is malformed, version entry complying to format '^== version=)(\\d+)' missing`)
      }
      if (isTableBegin) {
        throw new Error(`Invalid format: content is malformed, multiple COLUMN TABLE definitions found`)
      }
      if (isMigration) {
        throw new Error(`Invalid format: content is malformed, migrations must not be mixed with COLUMN TABLE definitions`)
      }
      isTableBegin = true
    } else if (isTableBegin && /^\)$/.test(row)) {
      if (isTableEnd) {
        throw new Error(`Invalid format: content is malformed, multiple COLUMN TABLE matching closing brackets found`)
      }
      if (isMigration) {
        throw new Error(`Invalid format: content is malformed, migrations must not be mixed with COLUMN TABLE definitions`)
      }
      isTableEnd = true
    } else if (!isMigration && /^== migration=/.test(row)) {
      if (!isVersion) {
        throw new Error(`Invalid format: content is malformed, version entry complying to format '^== version=)(\\d+)' missing`)
      }
      if (!isTableBegin) {
        throw new Error(`Invalid format: content is malformed, COLUMN TABLE missing`)
      }
      if (!isTableEnd) {
        throw new Error(`Invalid format: content is malformed, COLUMN TABLE matching closing bracket missing`)
      }
      isMigration = true
    }
  })
}

function parseTableStatement(content) {
  return _parseTableStatement(content.split('\n')).trim()
}

function _parseMigrations(rows) {
  let isMigration = false
  return rows.filter(row => {
    if (!isMigration && /^== migration=/.test(row)) {
      isMigration = true;
    }
    return isMigration;
  }).join('\n');
}

function _parseVersion(rows) {
  let version = -1;
  const versionRow = rows.find(row => /^== version=/.test(row))
  if (versionRow) {
    const match = versionRow.match(/(^== version=)(\d+$)/)
    if (match && match.length === 3) {
      version = parseInt(match[2])
    }
  }
  if (version === -1) {
    throw new Error(`Invalid format: ${versionRow ? versionRow : ""} is malformed, format '(^== version=)($\\d+$)' expected`)
  }
  return version
}

function _parseTableStatement(rows) {
  let isTableBegin = false, isTableEnd = false
  return rows.filter((row, idx) => {
    if (!isTableBegin && /^COLUMN TABLE/.test(row)) {
      isTableBegin = true
    } else if (isTableBegin && !isTableEnd && /^\)$/.test(rows[idx - 1])) {
      isTableEnd = true;
      return isTableEnd
    }
    return isTableBegin && !isTableEnd;
  }).join('\n');
}